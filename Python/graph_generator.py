import os
import utilities
import QSV_H264
import QSV_VP9
import H264
import VP9
import plot_generator
import joint_plot_generator
import resolution_comparison
import sys


class BestConfig:
    def __init__(self, best_config_report_path, best_config_name, resolution_name):
        self.best_config_report_path = best_config_report_path
        self.best_config_name = best_config_name
        self.resolution_name = resolution_name


_encoders = [QSV_H264.TAG, QSV_VP9.TAG, H264.TAG, VP9.TAG]


# Find files.
def run(run_folder):

    # Generate resolutions in the form that matches substrings in report name
    resolutions = ['-' + item[0] + '-' for item in utilities.RESOLUTIONS]

    datasets = os.listdir(run_folder)

    for dataset in datasets:
        joint_plot_encoders = []

        # Get report names from current datasets
        reports = next(os.walk(run_folder + '/' + dataset + '/best_config_report'))[2]

        # Iterate available encoders
        for i, _encoder in enumerate(_encoders):
            best_configs = []
            ordered_best_configs = []

            # Extract reports generated by current encoder
            reports_w_current_encoder = list(filter(lambda x: _encoder in x, reports))

            # Order reports after order in resolutions list (smaller -> larger)
            for res in resolutions:
                ordered_best_configs.append(next((s for s in reports_w_current_encoder if res in s), None))

            # Get rid of None elements
            ordered_best_configs = list(filter(None, ordered_best_configs))

            # Remove elements from original list to not do redundant work
            for r in ordered_best_configs:
                reports.remove(r)

            # Iterate the reports generated from current encoder
            for report in ordered_best_configs:
                best_config_report_path = run_folder + '/' + dataset + '/reports/' + report

                # Extract the resolution name from the report name
                resolution_name = next((x for x in resolutions if x in report), 'not_set')[1:-1]

                if not best_config_report_path[-4:] == '.csv':
                    print('Reports can only be of type .csv')
                    continue

                if resolution_name == 'not_set':
                    print(
                        "Unknown reslution in: " + report + ". Make sure that the resolution is added to the list"
                            "\'RESOLUTIONS\' in utilities.py ")
                    continue

                best_configs.append(utilities.BestConfig(
                    best_config_report_path=best_config_report_path,
                    best_config_name=report,
                    resolution_name=resolution_name))

            # Runs the plot_generator script to generate a performance graph of the current encoder and all resolutions
            plot_generator.run(best_configs=best_configs, dataset=dataset, codec=_encoder, output_path=run_folder +
                                '/' + dataset + '/encoder_graphs')

            # Add an Encoder object after each encoders' full execution on a dataset
            joint_plot_encoders.append(utilities.Encoder(
                best_configs=best_configs,
                encoder=_encoder,
                dataset_name=dataset))

        # Warn if a report is generated by an unknown encoder
        if i == len(_encoders) - 1 and len(reports) != 0:
            if not len(reports) == 1 and reports[0] == 'not_set':
                print("Unknown encoder(s) used to generate the following reports: " + str(reports) + ". Please add the "
                        "encoders to the _encoders list in graph_generator.py")


        # Generate comparision graphs
        joint_plot_generator.run(joint_plot_encoders, run_folder + '/' + dataset + '/joint_graphs')
        resolution_comparison.run(joint_plot_encoders, run_folder + '/' + dataset + '/comparison_graphs')

if __name__ == '__main__':
    run(sys.argv[1])